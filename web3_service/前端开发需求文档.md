# Web3钱包服务 - 前端开发需求文档

## 1. 项目概述

### 1.1 背景
Web3钱包服务是一个用于管理EVM和Solana区块链钱包的后端服务，支持钱包的创建、导入、查询和地址映射管理。

### 1.2 目标
为前端提供与后端服务交互的API集成方案，确保**pwd（密码）和私钥**在传输过程中的安全性。

### 1.3 技术栈要求
- 前端框架：React / Vue（任选其一）
- HTTP请求库：Axios
- 加密库：CryptoJS（用于AES加密）
- 环境变量管理：.env文件

---

## 2. 安全要求

### 2.1 pwd加密传输
**核心安全措施**：所有涉及pwd参数的API请求，必须先对pwd进行AES加密后再传输。

#### 加密密钥配置
- 密钥存储位置：前端环境变量文件（.env）
- 环境变量名称：`REACT_APP_PWD_DECRYPT_KEY` 或 `VITE_APP_PWD_DECRYPT_KEY`（取决于前端框架）
- 密钥值：需与后端 `.env` 文件中的 `PWD_DECRYPT_KEY` 一致
- **重要**：密钥不得硬编码在源代码中，必须通过环境变量注入

#### 环境变量配置示例
```bash
# .env 文件
REACT_APP_PWD_DECRYPT_KEY=your_secure_pwd_decrypt_key
```

### 2.2 私钥加密传输
**核心安全措施**：私钥在传输过程中也需要进行AES加密保护。

#### 传输流程
- **查询钱包时**：后端返回的`privateKey`和`phrase`字段是使用`PWD_DECRYPT_KEY`加密后的数据，前端需要解密后才能使用
- **导入钱包时**：前端需要先使用`PWD_DECRYPT_KEY`对私钥和助记词进行加密后再传输

#### walletList格式要求
```javascript
// 导入钱包时的walletList格式
const walletList = [
  "地址1,加密私钥1,加密助记词1",
  "地址2,加密私钥2,加密助记词2"
];
// 例如： "0x123...,U2FsdGVkX1+abc...,U2FsdGVkX1+xyz..."
```

### 2.2 加密算法规范
- **算法**：AES-256-CBC
- **密钥处理**：使用SHA256对密钥进行哈希处理
- **IV向量**：固定为16个零字节 `0000000000000000`
- **填充方式**：PKCS7
- **输出编码**：Base64

---

## 3. 前端开发任务

### 3.1 必需功能

#### 3.1.1 pwd和私钥加密工具模块
创建独立的加密工具模块，提供以下功能：

```javascript
// src/utils/crypto.js

import CryptoJS from 'crypto-js';

// 从环境变量获取密钥
const PWD_DECRYPT_KEY = process.env.REACT_APP_PWD_DECRYPT_KEY;

/**
 * 加密pwd
 * @param {string} pwd 原始密码
 * @returns {string} 加密后的密码（Base64编码）
 */
export function encryptPwd(pwd) {
  if (!pwd) return pwd;
  
  // 计算SHA256密钥
  const key = CryptoJS.SHA256(PWD_DECRYPT_KEY);
  
  // AES加密
  const iv = CryptoJS.enc.Utf8.parse('0000000000000000');
  const encrypted = CryptoJS.AES.encrypt(pwd, key, {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  
  return encrypted.toString(CryptoJS.enc.Base64);
}

/**
 * 解密pwd（仅用于本地验证）
 * @param {string} encryptedPwd 加密后的密码
 * @returns {string} 原始密码
 */
export function decryptPwd(encryptedPwd) {
  if (!encryptedPwd) return encryptedPwd;
  
  try {
    const key = CryptoJS.SHA256(PWD_DECRYPT_KEY);
    const iv = CryptoJS.enc.Utf8.parse('0000000000000000');
    
    const decrypted = CryptoJS.AES.decrypt(encryptedPwd, key, {
      iv: iv,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
    });
    
    return decrypted.toString(CryptoJS.enc.Utf8);
  } catch (error) {
    console.error('pwd解密失败:', error);
    return null;
  }
}

/**
 * 加密私钥（用于导入钱包时传输）
 * @param {string} privateKey 原始私钥
 * @returns {string} 加密后的私钥（Base64编码）
 */
export function encryptPrivateKey(privateKey) {
  if (!privateKey) return privateKey;
  
  const key = CryptoJS.SHA256(PWD_DECRYPT_KEY);
  const iv = CryptoJS.enc.Utf8.parse('0000000000000000');
  
  const encrypted = CryptoJS.AES.encrypt(privateKey, key, {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  
  return encrypted.toString(CryptoJS.enc.Base64);
}

/**
 * 解密私钥（用于查询钱包后获得原始数据）
 * @param {string} encryptedPrivateKey 加密后的私钥
 * @returns {string} 原始私钥
 */
export function decryptPrivateKey(encryptedPrivateKey) {
  if (!encryptedPrivateKey) return encryptedPrivateKey;
  
  try {
    const key = CryptoJS.SHA256(PWD_DECRYPT_KEY);
    const iv = CryptoJS.enc.Utf8.parse('0000000000000000');
    
    const decrypted = CryptoJS.AES.decrypt(encryptedPrivateKey, key, {
      iv: iv,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
    });
    
    return decrypted.toString(CryptoJS.enc.Utf8);
  } catch (error) {
    console.error('私钥解密失败:', error);
    return null;
  }
}

/**
 * 加密助记词（用于导入钱包时传输）
 * @param {string} phrase 原始助记词
 * @returns {string} 加密后的助记词（Base64编码）
 */
export function encryptPhrase(phrase) {
  return encryptPrivateKey(phrase);
}

/**
 * 解密助记词（用于查询钱包后获得原始数据）
 * @param {string} encryptedPhrase 加密后的助记词
 * @returns {string} 原始助记词
 */
export function decryptPhrase(encryptedPhrase) {
  return decryptPrivateKey(encryptedPhrase);
}
```

#### 3.1.2 API请求封装
创建统一的API请求模块，自动处理pwd加密：

```javascript
// src/api/index.js

import axios from 'axios';
import { encryptPwd } from '../utils/crypto';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3000';

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// 请求拦截器
apiClient.interceptors.request.use(
  config => {
    // 自动加密pwd字段
    if (config.data && config.data.pwd) {
      config.data.pwd = encryptPwd(config.data.pwd);
    }
    // 处理GET请求的pwd参数
    if (config.method === 'get' && config.params && config.params.pwd) {
      config.params.pwd = encryptPwd(config.params.pwd);
    }
    return config;
  },
  error => Promise.reject(error)
);

export default apiClient;
```

#### 3.1.3 API接口封装
封装所有与钱包相关的API接口：

```javascript
// src/api/wallet.js

import apiClient from './index';

/**
 * 获取钱包项目列表
 */
export function getWalletProjects() {
  return apiClient.get('/wallet/projects');
}

/**
 * 查询钱包列表
 * @param {Object} params 查询参数
 * @param {string} params.address 钱包地址（可选）
 * @param {string} params.project 项目标识（可选）
 * @param {string} params.pwd 密码（自动加密）
 */
export function walletList(params) {
  return apiClient.post('/wallet/list', params);
}

/**
 * 查询单个钱包
 * @param {string} address 钱包地址
 * @param {string} pwd 密码（自动加密）
 */
export function oneWallet(address, pwd) {
  return apiClient.get('/wallet/one', {
    params: { address, pwd }
  });
}

/**
 * 批量导入钱包
 * @param {Object} data 导入数据
 * @param {string[]} data.walletList 钱包列表，格式：["地址,加密私钥,加密助记词", ...]
 * @param {string} data.project 项目标识
 * @param {string} data.remark 备注
 * @param {string} data.pwd 密码（自动加密）
 * @param {boolean} data.autoEncrypt 是否自动加密私钥（默认true）
 */
export function insertWalletList(data) {
  // 如果需要自动加密私钥
  if (data.autoEncrypt !== false) {
    data.walletList = data.walletList.map(item => {
      const parts = item.split(',');
      if (parts.length >= 2) {
        parts[1] = encryptPrivateKey(parts[1]); // 加密私钥
      }
      if (parts.length >= 3) {
        parts[2] = encryptPhrase(parts[2]); // 加密助记词
      }
      return parts.join(',');
    });
  }
  return apiClient.post('/wallet/insert', data);
}

/**
 * 批量创建钱包
 * @param {Object} data 创建数据
 * @param {string} data.type 钱包类型（evm/sol）
 * @param {number} data.number 创建数量
 * @param {string} data.project 项目标识
 * @param {string} data.remark 备注
 * @param {string} data.pwd 密码（自动加密）
 */
export function createWalletList(data) {
  return apiClient.post('/wallet/create', data);
}
```

### 3.2 推荐功能

#### 3.2.1 密码输入组件
创建统一的密码输入组件：

```jsx
// src/components/PasswordInput/index.jsx

import React, { useState } from 'react';
import { encryptPwd } from '../../utils/crypto';

export default function PasswordInput({ value, onChange, ...props }) {
  const handleChange = (e) => {
    // 可选：实时加密或提交时加密
    onChange && onChange(e.target.value);
  };
  
  return (
    <input
      type="password"
      value={value}
      onChange={handleChange}
      {...props}
    />
  );
}
```

#### 3.2.2 错误处理
在API请求中处理解密失败的情况：

```javascript
// src/api/errorHandler.js

export function handleApiError(error) {
  if (error.response) {
    const { code, msg } = error.response.data;
    
    switch (code) {
      case -1:
        // 业务错误
        console.error('操作失败:', msg);
        break;
      default:
        console.error('未知错误:', msg);
    }
  } else if (error.request) {
    console.error('网络错误，请检查连接');
  } else {
    console.error('请求配置错误:', error.message);
  }
}
```

---

## 4. 开发流程

### 4.1 环境配置
1. 在项目根目录创建 `.env` 文件
2. 添加环境变量配置
3. 在代码中通过 `process.env` 访问

```bash
# .env
REACT_APP_API_BASE_URL=http://localhost:3000
REACT_APP_PWD_DECRYPT_KEY=your_secure_pwd_decrypt_key
```

### 4.2 依赖安装
```bash
npm install axios crypto-js
# 或
yarn add axios crypto-js
```

### 4.3 目录结构建议
```
src/
├── api/
│   ├── index.js          # API请求封装
│   ├── wallet.js         # 钱包相关接口
│   └── errorHandler.js   # 错误处理
├── utils/
│   └── crypto.js         # 加密工具函数
├── components/
│   └── PasswordInput/    # 密码输入组件
└── pages/
    └── Wallet/           # 钱包管理页面
```

---

## 5. 测试要点

### 5.1 单元测试
测试加密工具函数：

```javascript
// src/utils/crypto.test.js

import { encryptPwd, decryptPwd, encryptPrivateKey, decryptPrivateKey } from '../crypto';

describe('pwd加密工具', () => {
  const testPwd = 'mysecretkey';
  
  test('加密后应该得到Base64字符串', () => {
    const encrypted = encryptPwd(testPwd);
    expect(encrypted).toMatch(/^[A-Za-z0-9+/=]+$/);
  });
  
  test('加密再解密应该得到原始密码', () => {
    const encrypted = encryptPwd(testPwd);
    const decrypted = decryptPwd(encrypted);
    expect(decrypted).toBe(testPwd);
  });
  
  test('空密码应该返回空字符串', () => {
    expect(encryptPwd('')).toBe('');
    expect(encryptPwd(null)).toBe('');
    expect(encryptPwd(undefined)).toBe('');
  });
});

describe('私钥加密工具', () => {
  const testPrivateKey = '0xabcdef1234567890';
  const testPhrase = 'word1 word2 word3 word4 word5 word6 word7 word8 word8 word10 word11 word12';
  
  test('私钥加密后应该得到Base64字符串', () => {
    const encrypted = encryptPrivateKey(testPrivateKey);
    expect(encrypted).toMatch(/^[A-Za-z0-9+/=]+$/);
  });
  
  test('私钥加密再解密应该得到原始私钥', () => {
    const encrypted = encryptPrivateKey(testPrivateKey);
    const decrypted = decryptPrivateKey(encrypted);
    expect(decrypted).toBe(testPrivateKey);
  });
  
  test('助记词加密再解密应该得到原始助记词', () => {
    const encrypted = encryptPrivateKey(testPhrase);
    const decrypted = decryptPrivateKey(encrypted);
    expect(decrypted).toBe(testPhrase);
  });
});
```

### 5.2 集成测试
1. 测试完整的API请求流程
2. 验证后端能够正确解密前端传来的pwd
3. 验证错误的pwd无法解密数据
4. 测试查询钱包时后端返回的私钥是加密的
5. 测试导入钱包时私钥正确加密后能被后端解密

### 5.3 安全测试
1. 确认pwd不以明文形式出现在网络请求中
2. 确认私钥不以明文形式出现在网络请求中
3. 确认密钥不从源代码中泄露
4. 确认不同请求使用相同的加密结果（基于AES特性）

---

## 6. 部署注意事项

### 6.1 环境变量
- **开发环境**：使用 `.env.development` 文件
- **生产环境**：使用 `.env.production` 文件
- 确保生产环境的 `PWD_DECRYPT_KEY` 与后端一致

### 6.2 安全性
- 不要将密钥提交到版本控制系统
- 使用CI/CD工具的安全变量管理功能
- 定期轮换密钥

### 6.3 兼容性
- 确保使用的CryptoJS版本兼容目标浏览器
- 测试不同浏览器（Chrome、Firefox、Safari、Edge）

---

## 7. 常见问题

### Q1: 为什么需要加密pwd传输？
A: pwd用于解密数据库中存储的私钥和助记词。如果pwd以明文传输，容易被中间人攻击获取，导致钱包资产被盗。

### Q2: 为什么需要加密私钥传输？
A: 私钥是控制钱包资产的唯一凭证，如果以明文传输，被截获后可以直接转移资产。通过加密传输，即使请求被拦截，攻击者也无法获取原始私钥。

### Q3: 前后端密钥不一致会怎样？
A: 后端将无法正确解密pwd或私钥，导致API请求失败，返回解密相关错误。

### Q4: 如何验证加密是否生效？
A: 可以使用浏览器的开发者工具查看网络请求：
- 确认pwd字段是Base64编码的密文而非明文密码
- 确认privateKey字段是Base64编码的密文而非原始私钥

### Q5: 能否在前端解密pwd或私钥？
A: 不建议在前端解密pwd或私钥，这会暴露密钥。前端只需负责加密，后端负责解密。

### Q6: 忘记密钥怎么办？
A: 密钥存储在后端 `.env` 文件中，查看后端服务器配置即可。

### Q7: 导入钱包时私钥格式是什么？
A: 导入钱包时，walletList中每个钱包的格式为：
```
"地址,加密私钥,加密助记词"
```
例如：
```
"0x1234567890abcdef...,U2FsdGVkX1+abc...,U2FsdGVkX1+xyz..."
```

---

## 8. 参考资料

- [CryptoJS文档](https://cryptojs.gitbook.io/docs/)
- [AES加密算法](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)
- [环境变量管理](https://create-react-app.dev/docs/adding-custom-environment-variables/)
- [后端API文档](./API文档.md)

---

## 9. 变更日志

| 版本 | 日期 | 变更内容 |
|------|------|----------|
| 1.2 | 2024-01-09 | 修复加密示例代码，确保与后端配置一致（SHA256密钥、IV、CBC模式、PKCS7填充） |
| 1.1 | 2024-01-09 | 增加私钥加密传输功能：查询返回加密私钥，导入时需加密私钥 |
| 1.0 | 2024-01-09 | 初始版本，增加pwd加密传输功能 |

---

**文档版本**: 1.1  
**最后更新**: 2024-01-09  
**维护者**: 后端开发团队
